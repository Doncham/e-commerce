Redis 기반 인기 상품 랭킹 시스템 설계 및 구현 보고서
1. 목표와 배경
   1.1 요구사항

최근 7일 / 30일 동안 결제 완료(PAID) 된 주문 수량을 기반으로 인기 상품 랭킹을 제공한다.

인기 상품 조회 요청이 많을 때, 매 요청마다 DB에서 집계 및 정렬을 수행하면 DB 부하가 급증한다.

따라서 Redis 캐시를 활용해 조회 성능을 높이고 DB 부하를 줄인다.

1.2 목표

DB 집계 쿼리 수행 빈도를 최소화하고, 인기 상품 조회를 Redis 중심으로 처리한다.

랭킹 정렬 기준을 안정적으로 유지하고(동점 처리), 상품 상세정보 조회 성능도 함께 최적화한다.

Redis 장애가 결제 트랜잭션을 깨지 않도록 결제 로직과 Redis 갱신을 분리한다.

2. 전체 아키텍처 개요
   2.1 데이터 흐름 요약

배치(매일 00:00): DB에서 7일/30일 집계를 수행하여 Redis ZSET을 재구축한다.

실시간 증분: 결제 성공 이벤트 발생 시 Redis ZSET 점수(score)를 증가시켜 랭킹을 최신 상태에 가깝게 유지한다.

2-tier 캐시:

1-tier: 랭킹 ZSET에 있는 상품 ID 목록

2-tier: 상품 상세 스냅샷(ProductSnap) 캐시

3. Redis 키 설계
   3.1 랭킹 키(ZSET)

rank:7d / rank:30d : 최종 랭킹

배치 빌드용 임시 키

rank:7d:tmp

rank:30d:tmp

ZSET 구조:

member: productId

score: soldQty + 타이브레이커 인코딩 값(아래 5장 참고)

3.2 상품 상세 스냅샷 키(String)

product:snap:{productId}

value: ProductSnap JSON 문자열

TTL: 예) 7일 또는 요구사항에 맞춘 기간

4. 랭킹 갱신 전략
   4.1 배치 갱신(매일 00:00)
   목적

집계의 기준을 DB로 정리하여 랭킹의 “정합성 기준점”을 만든다.

방식

DB에서 기간별(7d, 30d) 결제 완료 내역을 집계하여 Top N을 조회한다.

결과를 rank:*:tmp에 ZADD로 재구축한다.

최종 키로 스왑하여 사용자 조회가 항상 안정적으로 동작하게 한다.

임시 키를 쓰는 이유:

배치 중간 상태를 사용자에게 노출하지 않기 위해서(원자적 교체 효과)

배치 실패 시 기존 랭킹을 유지할 수 있어 안전하다.

4.2 실시간 증분 갱신(결제 성공 시)
문제

결제 성공 직후 랭킹 반영을 결제 트랜잭션에 포함하면:

Redis 장애/지연이 결제 롤백으로 이어져 비즈니스적으로 치명적이다.

해결: Outbox 이벤트 기반 비동기 처리

결제 성공 시 Outbox에 이벤트를 저장한다.

별도 소비자가 이벤트를 읽어 Redis ZSET 점수를 증가시킨다.

Redis 예외가 결제 트랜잭션을 깨지 않으며, 시스템 전체 안정성이 좋아진다.

5. 타이브레이커 설계
   5.1 필요성

판매량(soldQty)이 동일한 상품이 존재할 경우 랭킹의 순서가 매 요청마다 흔들릴 수 있다.
따라서 “동점 시 어떤 상품을 먼저 보여줄지”를 명확히 정의해야 한다.

5.2 기준

먼저 생성된 상품이 더 높은 우선순위를 갖는다.

productId는 일반적으로 “먼저 생성될수록 값이 작다”는 특성을 가지므로 이를 활용한다.

5.3 score 인코딩

score에 soldQty와 productId 기반 tie 값을 함께 인코딩한다.

PopularScoreCodec를 통해 encode/decode 로직을 통일한다.

효과:

ZSET 정렬 기준이 안정적으로 고정된다.

랭킹이 흔들리지 않아 사용자 경험이 개선된다.

6. 2-tier 캐시 설계
   6.1 목적

인기 상품 조회 시:

랭킹은 Redis에서 빠르게 얻을 수 있지만

각 상품의 상세정보를 매번 DB에서 조회하면 DB 부하가 다시 커진다.

따라서 랭킹과 상세정보를 분리하여 캐싱한다.

6.2 구조

1-tier 캐시: 랭킹 ZSET (productId, score)

2-tier 캐시: product:snap:{productId} (상품 상세 스냅샷 JSON)

6.3 스냅샷 프리워밍(배치 시점)

배치 갱신 시 Top N 상품(예: 50개)의 상세정보를 미리 캐싱한다.

조회 트래픽이 몰리는 구간에서 캐시 hit율을 높인다.

사용자 첫 요청의 지연을 줄인다.

7. 인기 상품 조회 플로우
Step 1) ZSET에서 rankedProductIds 가져오기

reverseRangeWithScores로 랭킹 순서대로 조회한다.

랭킹 순서를 유지한 rankedProductIds 리스트를 만든다.

score는 PopularScoreCodec.decodeQty로 복원하여 soldQtyMap(productId -> soldQty)에 저장한다.

Step 2) Tier2 캐시 MGET으로 상세 스냅샷 조회

product:snap:{productId} 키들을 만들어 MGET 수행

결과 JSON을 ObjectMapper로 파싱해 snapMap(productId -> ProductSnap) 구성

캐시가 비어있는 상품은 missedIds에 모은다.

Step 3) missedIds만 DB 조회

캐시 미스가 난 상품만 DB에서 조회하여 비용을 최소화한다.

Step 4) DB 결과를 Redis에 캐싱

미스 난 상품을 ProductSnap으로 만들고 Redis에 저장한다(파이프라인 가능).

다음 조회부터는 캐시 hit이 발생한다.

Step 5) 응답 조립

ZSET 순서대로(rank 유지) ProductSnap + soldQty를 결합하여 응답 리스트 생성

클라이언트에 인기 상품 응답 반환

8. 장애 및 정합성 고려
   8.1 Redis 장애가 결제에 영향 주지 않도록 분리

Redis 증분 갱신은 Outbox 이벤트로 분리한다.

Redis 오류는 랭킹 최신성에만 영향을 주며 결제는 정상 완료된다.

8.2 정합성 보정

실시간 증분 누락/중복 가능성은 존재할 수 있으므로

매일 00:00 배치가 DB 기반으로 재구축하여 정합성을 주기적으로 보정한다.

8.3 캐시 미스/깨진 캐시 처리

JSON 파싱 실패 시 해당 키를 삭제하고 DB 조회로 fallback 한다.

조회 결과 정확성은 유지하면서, 깨진 캐시는 자연스럽게 복구된다.

9. 기대 효과
   9.1 DB 부하 감소

인기 상품 조회 시 DB 집계 쿼리를 매번 수행하지 않음

캐시 미스 상품만 DB를 조회하므로 조회 비용이 크게 감소

9.2 조회 성능 향상

랭킹 조회는 Redis ZSET O(logN) 기반

상품 상세정보는 MGET으로 네트워크 왕복 최소화

9.3 사용자 경험 개선

타이브레이커로 랭킹이 흔들리지 않음

프리워밍으로 첫 조회 지연 감소

10. 결론

본 설계는 “최근 7/30일 인기 상품 랭킹”을 Redis 중심으로 제공하여 DB 부하를 줄이고, 배치 재구축과 Outbox 기반 증분 갱신을 결합해 정합성과 최신성을 함께 확보한다.
또한 2-tier 캐시를 적용해 랭킹뿐 아니라 상품 상세 조회 비용까지 최적화하여 트래픽이 증가해도 안정적으로 인기 상품 조회 기능을 제공한다.